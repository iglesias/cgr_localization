/* Auto-generated by genmsg_cpp for file /home/nando/workspace/ros/fuerte_workspace/sandbox/cgr_localization/msg/LocalizationMsg.msg */
#ifndef CGR_LOCALIZATION_MESSAGE_LOCALIZATIONMSG_H
#define CGR_LOCALIZATION_MESSAGE_LOCALIZATIONMSG_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace cgr_localization
{
template <class ContainerAllocator>
struct LocalizationMsg_ {
  typedef LocalizationMsg_<ContainerAllocator> Type;

  LocalizationMsg_()
  : timeStamp(0.0)
  , x(0.0)
  , y(0.0)
  , angle(0.0)
  , angleUncertainty(0.0)
  , locationUncertainty(0.0)
  , map()
  , lastLaserRunTime(0.0)
  , laserRunTime(0.0)
  , laserNumObservedPoints(0)
  , laserNumCorrespondences(0)
  , laserStage0Weights(0.0)
  , laserStageRWeights(0.0)
  , laserMeanSqError(0.0)
  , lastPointCloudRunTime(0.0)
  , pointCloudRunTime(0.0)
  , pointCloudNumObservedPoints(0)
  , pointCloudNumCorrespondences(0)
  , pointCloudStage0Weights(0.0)
  , pointCloudStageRWeights(0.0)
  , pointCloudMeanSqError(0.0)
  {
  }

  LocalizationMsg_(const ContainerAllocator& _alloc)
  : timeStamp(0.0)
  , x(0.0)
  , y(0.0)
  , angle(0.0)
  , angleUncertainty(0.0)
  , locationUncertainty(0.0)
  , map(_alloc)
  , lastLaserRunTime(0.0)
  , laserRunTime(0.0)
  , laserNumObservedPoints(0)
  , laserNumCorrespondences(0)
  , laserStage0Weights(0.0)
  , laserStageRWeights(0.0)
  , laserMeanSqError(0.0)
  , lastPointCloudRunTime(0.0)
  , pointCloudRunTime(0.0)
  , pointCloudNumObservedPoints(0)
  , pointCloudNumCorrespondences(0)
  , pointCloudStage0Weights(0.0)
  , pointCloudStageRWeights(0.0)
  , pointCloudMeanSqError(0.0)
  {
  }

  typedef double _timeStamp_type;
  double timeStamp;

  typedef float _x_type;
  float x;

  typedef float _y_type;
  float y;

  typedef float _angle_type;
  float angle;

  typedef float _angleUncertainty_type;
  float angleUncertainty;

  typedef float _locationUncertainty_type;
  float locationUncertainty;

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _map_type;
  std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  map;

  typedef double _lastLaserRunTime_type;
  double lastLaserRunTime;

  typedef double _laserRunTime_type;
  double laserRunTime;

  typedef int32_t _laserNumObservedPoints_type;
  int32_t laserNumObservedPoints;

  typedef int32_t _laserNumCorrespondences_type;
  int32_t laserNumCorrespondences;

  typedef float _laserStage0Weights_type;
  float laserStage0Weights;

  typedef float _laserStageRWeights_type;
  float laserStageRWeights;

  typedef float _laserMeanSqError_type;
  float laserMeanSqError;

  typedef double _lastPointCloudRunTime_type;
  double lastPointCloudRunTime;

  typedef double _pointCloudRunTime_type;
  double pointCloudRunTime;

  typedef int32_t _pointCloudNumObservedPoints_type;
  int32_t pointCloudNumObservedPoints;

  typedef int32_t _pointCloudNumCorrespondences_type;
  int32_t pointCloudNumCorrespondences;

  typedef float _pointCloudStage0Weights_type;
  float pointCloudStage0Weights;

  typedef float _pointCloudStageRWeights_type;
  float pointCloudStageRWeights;

  typedef float _pointCloudMeanSqError_type;
  float pointCloudMeanSqError;


  typedef boost::shared_ptr< ::cgr_localization::LocalizationMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::cgr_localization::LocalizationMsg_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct LocalizationMsg
typedef  ::cgr_localization::LocalizationMsg_<std::allocator<void> > LocalizationMsg;

typedef boost::shared_ptr< ::cgr_localization::LocalizationMsg> LocalizationMsgPtr;
typedef boost::shared_ptr< ::cgr_localization::LocalizationMsg const> LocalizationMsgConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::cgr_localization::LocalizationMsg_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::cgr_localization::LocalizationMsg_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace cgr_localization

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::cgr_localization::LocalizationMsg_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::cgr_localization::LocalizationMsg_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::cgr_localization::LocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "88e4cd133e897255a68320aa8fedc7f7";
  }

  static const char* value(const  ::cgr_localization::LocalizationMsg_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x88e4cd133e897255ULL;
  static const uint64_t static_value2 = 0xa68320aa8fedc7f7ULL;
};

template<class ContainerAllocator>
struct DataType< ::cgr_localization::LocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "cgr_localization/LocalizationMsg";
  }

  static const char* value(const  ::cgr_localization::LocalizationMsg_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::cgr_localization::LocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "float64 timeStamp\n\
float32 x\n\
float32 y\n\
float32 angle\n\
float32 angleUncertainty\n\
float32 locationUncertainty\n\
string map\n\
\n\
float64 lastLaserRunTime\n\
float64 laserRunTime\n\
int32 laserNumObservedPoints\n\
int32 laserNumCorrespondences\n\
float32 laserStage0Weights\n\
float32 laserStageRWeights\n\
float32 laserMeanSqError\n\
\n\
float64 lastPointCloudRunTime\n\
float64 pointCloudRunTime\n\
int32 pointCloudNumObservedPoints\n\
int32 pointCloudNumCorrespondences\n\
float32 pointCloudStage0Weights\n\
float32 pointCloudStageRWeights\n\
float32 pointCloudMeanSqError\n\
\n\
\n\
";
  }

  static const char* value(const  ::cgr_localization::LocalizationMsg_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::cgr_localization::LocalizationMsg_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.timeStamp);
    stream.next(m.x);
    stream.next(m.y);
    stream.next(m.angle);
    stream.next(m.angleUncertainty);
    stream.next(m.locationUncertainty);
    stream.next(m.map);
    stream.next(m.lastLaserRunTime);
    stream.next(m.laserRunTime);
    stream.next(m.laserNumObservedPoints);
    stream.next(m.laserNumCorrespondences);
    stream.next(m.laserStage0Weights);
    stream.next(m.laserStageRWeights);
    stream.next(m.laserMeanSqError);
    stream.next(m.lastPointCloudRunTime);
    stream.next(m.pointCloudRunTime);
    stream.next(m.pointCloudNumObservedPoints);
    stream.next(m.pointCloudNumCorrespondences);
    stream.next(m.pointCloudStage0Weights);
    stream.next(m.pointCloudStageRWeights);
    stream.next(m.pointCloudMeanSqError);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct LocalizationMsg_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::cgr_localization::LocalizationMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::cgr_localization::LocalizationMsg_<ContainerAllocator> & v) 
  {
    s << indent << "timeStamp: ";
    Printer<double>::stream(s, indent + "  ", v.timeStamp);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "angle: ";
    Printer<float>::stream(s, indent + "  ", v.angle);
    s << indent << "angleUncertainty: ";
    Printer<float>::stream(s, indent + "  ", v.angleUncertainty);
    s << indent << "locationUncertainty: ";
    Printer<float>::stream(s, indent + "  ", v.locationUncertainty);
    s << indent << "map: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.map);
    s << indent << "lastLaserRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.lastLaserRunTime);
    s << indent << "laserRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.laserRunTime);
    s << indent << "laserNumObservedPoints: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserNumObservedPoints);
    s << indent << "laserNumCorrespondences: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserNumCorrespondences);
    s << indent << "laserStage0Weights: ";
    Printer<float>::stream(s, indent + "  ", v.laserStage0Weights);
    s << indent << "laserStageRWeights: ";
    Printer<float>::stream(s, indent + "  ", v.laserStageRWeights);
    s << indent << "laserMeanSqError: ";
    Printer<float>::stream(s, indent + "  ", v.laserMeanSqError);
    s << indent << "lastPointCloudRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.lastPointCloudRunTime);
    s << indent << "pointCloudRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.pointCloudRunTime);
    s << indent << "pointCloudNumObservedPoints: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pointCloudNumObservedPoints);
    s << indent << "pointCloudNumCorrespondences: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pointCloudNumCorrespondences);
    s << indent << "pointCloudStage0Weights: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudStage0Weights);
    s << indent << "pointCloudStageRWeights: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudStageRWeights);
    s << indent << "pointCloudMeanSqError: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudMeanSqError);
  }
};


} // namespace message_operations
} // namespace ros

#endif // CGR_LOCALIZATION_MESSAGE_LOCALIZATIONMSG_H

